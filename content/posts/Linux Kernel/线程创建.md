## 任务管理

### 进程的实现原理

### fork创建进程的过程

### 进程pid管理

### 线程创建过程

### 进程与线程的对比

### ELF可执行文件基本格式

### 进程加载启动原理


### 任务调度

#### 线程的创建过程

首先明确一个观点, 从内核的视角来看,进程和线程没有任何区别
内核将它们统称为任务, 都是一个task_struct结构体, 调度等实现也没有任何区别, 上下文切换开销差异也不大
@detail : 如何证明线程进程上下文切换开销差异不大, 相同进程中的线程切换缓存命中率高点
只是在用户空间看来, 线程是轻量级的进程, 它们共享进程的地址空间, 而进程则不共享.

线程之间复用一套mm_struct, 而进程则不共享, 所以线程切换开销小, 进程切换开销大

### 线程创建的接口

```c
pid_t clone(int (*fn)(void *), void *child_stack, int flags, void *arg, ...
            /* pid_t *ptid, struct user_desc *tls, pid_t *ctid */ );
```

### 线程创建的流程

1. 调用do_fork函数, 创建子进程
2. 调用copy_process函数, 复制父进程的task_struct结构体, 创建子进程的task_struct结构体
3. 调用dup_task_struct函数, 复制父进程的task_struct结构体, 创建子进程的task_struct结构体
4. 调用copy_thread函数, 复制父进程的线程信息, 创建子进程的线程信息



## 线程的管理


